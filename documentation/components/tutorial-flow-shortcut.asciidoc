---
title: Shortcuts
order: 7
layout: page
---

= Shortcuts

== Overview

Shortcut feature enhances the developer with the ability to create custom
keyboard shortcuts and receive the notification when the shortcuts are used.

== Using Shortcuts

The main component of the shortcut API is `ShortcutRegistration`.
Registering a shortcut yields a `ShortcutRegistration` instance which can be
used to further configure and remove the registered shortcut. Both
`Focusable` and `ClickNotifier` interfaces offer shorthand methods for
registering shortcuts which perform the action specified by the interface;
`Focusable` components are focused and `ClickNotifier` components are clicked.

More flexible shortcut offerings are provided by `ShortcutActions` through
which a normal `Runnable` instance can be bound to a shortcut.

Here is a simple use-case where we want ENTER key to perform login on a
`TextField`:

[source, java]
----
TextField username = new TextField();
ShortcutActions.exec(this::login, username).on(Key.ENTER);
----

`ShortcutActions` class offers methods for registering a shortcut and
`ShortcutRegistration` is a result of such a registration.

The `ShortcutRegistration` offers the actual API for configuring the shortcut
itself: which keys to use...

[source, java]
----
shortcutRegistration.on('K').alt();
----

... who owns the shortcut, ...

[source, java]
----
shortcutRegistration.bindLifecycleTo(component);
----

\... inside which components the shortcut is handled, ...

[source, java]
----
shortcutRegistration.scope(myScopeComponent1, myScopeComponent2);
----

\... and how the JavaScript event should be treated (prevent default and stop
propagation options).

[source, java]
----
shortcutRegistration.preventDefault().stopPropagation();
----

// TODO: bring examples here. Closer to the descriptory text itself


// TODO: focus shortcut might have scope self instead
By default, the shortcuts registered by any means have a listening scope of
global. This means that the shortcut, when the keys are pressed, will be
invoked not matter what the user has focused on the page. If this is not
something you want to happen, you can control this by using
`ShortcutRegistration::scope(Component, Component...)`. This allows you to
select which components will catch the shortcut. Say you have a `<div>`
filled with text fields and you want a shortcut to work only when the user is
in one of those text fields. Set the scope to `<div>` and you are done:

[source, java]
----
Div myDivComponent = new Div();
shortcutRegistration.scope(myDivComponent);
----

In general, browser events are a complex topic. In order to generate events, a
non-input tag must be focusable by setting its `tabindex` property. For `<div>`
tags or other non-input tags, a good practice is to set the `tabindex="-1"`
since a negative value will exclude it from the tab sequence.

In addition to controlling the scope of a shortcut, you can also control the
owner of the shortcut. The owner controls _when_ the shortcut is available -
its life cycle is tied to that of the owner. In case of the shortcuts
created by `Focusable` or `ClickNotifier`, the owner is automatically the
component itself. When using the `ShortcutActions.exec(Runnable)` the owner
is `UI`; use the override `ShortcutActions.exec(Runnable, Component)` if you
want to specify the owner for these shortcuts.

=== Shortcuts by examples

The example below demonstrates how to configure both _focus_ and _click_
shortcuts:

[source, java]
----
TextField answerField = new TextField();
// focus the answerField pressing ALT+F
answerField.addFocusShortcut().on('F').alt();

Button submit = new Button();
submit.addClickListener(event -> submit());
// submit the answer by pressing ENTER
submit.addClickShortcut().on(Key.ENTER);
----

Many times you will need to execute arbitrary code in response to a shortcut.
`ShortcutActions.exec` method is meant just for that.

Here is an example on how we can add a global shortcut:

[source, java]
----
public class SomeView extends Div {
    private ShortcutRegistration shortcutRegistration;

    public SomeView() {
        shortcutRegistration = ShortcutActions.exec(
                () -> UI.getCurrent().navigate(MainView.class))
                .on(Key.BACKSPACE);
    }

    /**
     * Removes the registered global shortcut
     */
    private void removeShortcut() {
        if (shortcutRegistration != null) shortcutRegistration.remove();
    }
}
----

In this example we will expand on topic of scopes. We present a shortcut
owned by and scoped to a layout. Remember, the shortcut can only be invoked
when of the the elements inside the layout has focus.

[source, java]
----
public class LoginScreen extends FlexLayout {

    public LoginScreen() {
        TextField username = new TextField();
        TextField password = new TextField();
        Button login = new Button();
        login.addClickListener(event -> this.login());

        add(username);
        add(password);
        add(login);

        ShortcutActions.exec(this::login, this).scope(this).on(Key.ENTER);
    }

    private void login() {
        // Login goes here.
    }
}
----

This example presents the same functionality but implemented through the
_click_ shortcut. Notice that the scope is still the layout (if no scope is
set, it will be global).

[source, java]
----
public class LoginScreen extends FlexLayout {

    public LoginScreen() {
        TextField username = new TextField();
        TextField password = new TextField();
        Button login = new Button();
        login.addClickListener(event -> this.login());
        login.addClickShortcut().scope(this).on(Key.ENTER);

        add(username);
        add(password);
        add(login);
    }

    private void login() {
        // Login goes here.
    }
}
----

If you want to stop the keyboard event from propagating up the DOM tree once a
shortcut has been detected or prevent the default key actions from taking place
you can use the `ShortcutRegistration` to do that.

Below is an example how to produce '000' in a text field when the user
presses '*'.

[source, java]
----
TextField textField = new TextField();
// When the user presses '*', three zeros are added instead
ShortcutActions.exec(
        () -> textField.setValue(textField.getValue() + "000"), textField)
        .on(Key.MULTIPLY).scope(textField).preventDefault().stopPropagation();
----


In order to receive the event when none of the input fields are focused, but
user clicks somewhere on the form area itself, we need to implement `Focusable`
and set the `tabIndex` to e.g. -1:

[source, java]
----
public class LoginScreen extends FlexLayout implements Focusable {

    public LoginScreen() {
        // ...

        // Make the component selectable by the users' clicks
        setTabIndex(-1);

        // This removes the focus style when user clicks it.
        this.getElement().getStyle().set("outline", "none");

        // ...
    }
}
----